import java.awt.Color;
import java.util.Scanner;

public class FloodFillMain {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        System.out.print("Digite o caminho da imagem PNG de entrada: ");
        String caminhoEntrada = scanner.nextLine().trim();

        if (caminhoEntrada.isEmpty()) {
            caminhoEntrada = "entrada.png";
            System.out.println("Usando arquivo padrão: " + caminhoEntrada);
        }

        // Usamos um caminho base para os frames temporários, já que não vamos salvar o GIF final.
        // O ImageProcessor ainda precisa de um caminho de saída final.
        String caminhoSaidaBase = caminhoEntrada.replace(".png", "_resultado");
        String caminhoSaida = caminhoSaidaBase + ".png";


        ImageProcessor processador = new ImageProcessor(caminhoEntrada, caminhoSaida);

        if (!processador.carregarImagem()) {
            System.err.println("Não foi possível carregar a imagem. Encerrando.");
            scanner.close();
            return;
        }

        System.out.println("\nImagem carregada: " + processador.getLargura() + " x " + processador.getAltura() + " pixels");
        
        // Validação básica de entrada para x, y
        int x = -1, y = -1;
        try {
            System.out.print("Digite a coordenada X inicial (0 a " + (processador.getLargura() - 1) + "): ");
            x = scanner.nextInt();
            System.out.print("Digite a coordenada Y inicial (0 a " + (processador.getAltura() - 1) + "): ");
            y = scanner.nextInt();
        } catch (java.util.InputMismatchException e) {
            System.err.println("Coordenada inválida. Encerrando.");
            scanner.close();
            return;
        }


        System.out.print("Digite o valor R da nova cor (0-255): ");
        int r = Math.max(0, Math.min(255, scanner.nextInt()));

        System.out.print("Digite o valor G da nova cor (0-255): ");
        int g = Math.max(0, Math.min(255, scanner.nextInt()));

        System.out.print("Digite o valor B da nova cor (0-255): ");
        int b = Math.max(0, Math.min(255, scanner.nextInt()));

        Color novaCor = new Color(r, g, b);
        System.out.println("Nova cor selecionada: RGB(" + r + ", " + g + ", " + b + ")");

        System.out.println("\nEscolha a estrutura de dados:");
        System.out.println("1 - Pilha");
        System.out.println("2 - Fila");
        System.out.println("3 - Ambas (comparação)");
        System.out.print("Opção: ");
        int opcao = scanner.nextInt();

        System.out.print("\nDeseja exibir a **animação do processo no terminal**? (s/n): ");
        scanner.nextLine(); // Limpa o buffer
        String criarAnimacao = scanner.nextLine().toLowerCase();
        boolean gerarAnimacaoTerminal = criarAnimacao.equals("s") || criarAnimacao.equals("sim");
        
        // Pergunta extra para a animação
        boolean usarCoresAnsi = false;
        if (gerarAnimacaoTerminal) {
            System.out.print("Deseja usar cores ANSI (requer terminal compatível)? (s/n): ");
            usarCoresAnsi = scanner.nextLine().toLowerCase().equals("s");
        }


        FloodFillAlgorithm algoritmo = new FloodFillAlgorithm(processador);
        long tempoInicio, tempoFim;

        // O base path para os frames será 'caminhoSaidaBase', pois o ImageProcessor
        // salvará os frames como 'caminhoSaidaBase_frame_XXXX.png'

        switch (opcao) {
            case 1:
                tempoInicio = System.currentTimeMillis();
                algoritmo.executarComPilha(x, y, novaCor);
                tempoFim = System.currentTimeMillis();
                System.out.println("Tempo de execução (Pilha): " + (tempoFim - tempoInicio) + "ms");

                if (gerarAnimacaoTerminal) {
                    // MODIFICAÇÃO: Chama a função que exibe no terminal
                    exibirAnimacaoNoTerminal(caminhoSaidaBase, usarCoresAnsi);
                }
                break;

            case 2:
                tempoInicio = System.currentTimeMillis();
                algoritmo.executarComFila(x, y, novaCor);
                tempoFim = System.currentTimeMillis();
                System.out.println("Tempo de execução (Fila): " + (tempoFim - tempoInicio) + "ms");

                if (gerarAnimacaoTerminal) {
                    // MODIFICAÇÃO: Chama a função que exibe no terminal
                    exibirAnimacaoNoTerminal(caminhoSaidaBase, usarCoresAnsi);
                }
                break;

            case 3:
                // Novo processador para a FILA, garantindo que o P2 não sobrescreva os frames do P1.
                // Usaremos um caminho de saída diferente para os frames da Fila.
                String saidaBaseFila = caminhoEntrada.replace(".png", "_resultado_fila");
                ImageProcessor processador2 = new ImageProcessor(caminhoEntrada, saidaBaseFila + ".png");
                processador2.carregarImagem();
                FloodFillAlgorithm algoritmo2 = new FloodFillAlgorithm(processador2);

                System.out.println("\n--- Testando com PILHA ---");
                tempoInicio = System.currentTimeMillis();
                algoritmo.executarComPilha(x, y, novaCor); // Frame base: caminhoSaidaBase
                tempoFim = System.currentTimeMillis();
                long tempoPilha = tempoFim - tempoInicio;

                System.out.println("\n--- Testando com FILA ---");
                tempoInicio = System.currentTimeMillis();
                algoritmo2.executarComFila(x, y, novaCor); // Frame base: saidaBaseFila
                tempoFim = System.currentTimeMillis();
                long tempoFila = tempoFim - tempoInicio;

                System.out.println("\n=== COMPARAÇÃO DE DESEMPENHO ===");
                System.out.println("Tempo Pilha: " + tempoPilha + "ms");
                System.out.println("Tempo Fila: " + tempoFila + "ms");
                System.out.println("Diferença: " + Math.abs(tempoPilha - tempoFila) + "ms");

                processador2.salvarImagem();

                if (gerarAnimacaoTerminal) {
                    System.out.println("\nExibindo animações...");
                    // Animação da Pilha
                    System.out.println("--- Animação da PILHA ---");
                    exibirAnimacaoNoTerminal(caminhoSaidaBase, usarCoresAnsi);
                    
                    // Animação da Fila
                    System.out.println("\n--- Animação da FILA ---");
                    exibirAnimacaoNoTerminal(saidaBaseFila, usarCoresAnsi);
                }
                break;

            default:
                System.err.println("Opção inválida!");
                scanner.close();
                return;
        }

        processador.salvarImagem();

        System.out.println("\nProcessamento concluído!");
        System.out.println("Imagem resultado salva com sucesso.");
        if (opcao == 3) {
            System.out.println("Resultado (Pilha): " + caminhoSaida);
            System.out.println("Resultado (Fila): " + caminhoEntrada.replace(".png", "_resultado_fila.png"));
        }

        scanner.close();
    }


    /**
     * NOVO método para exibir a animação no terminal, substituindo a criação de GIF.
     * Utiliza a classe TerminalAnimator (que usa a ListaDinamica, o 'ArrayList do zero').
     */
    private static void exibirAnimacaoNoTerminal(String basePath, boolean usarCoresAnsi) {
        // O delay aqui é em milissegundos.
        int delayMs = 150; 
        
        try {
            // A classe TerminalAnimator carrega os frames e já os exibe no console.
            TerminalAnimator animator = new TerminalAnimator(basePath, delayMs);

            if (animator.getNumeroFrames() > 0) {
                animator.exibirNoTerminal(usarCoresAnsi); 
            } else {
                System.out.println(" Nenhum frame encontrado para exibir animação em: " + basePath);
            }

            // A limpeza dos frames é feita dentro do TerminalAnimator.exibirNoTerminal()
            
        } catch (Exception e) {
            System.err.println("Erro ao tentar exibir animação no terminal: " + e.getMessage());
            //e.printStackTrace();
        }
    }
}
